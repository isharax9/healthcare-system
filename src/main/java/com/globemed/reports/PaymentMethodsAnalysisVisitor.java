package com.globemed.reports;

import com.globemed.appointment.Appointment;
import com.globemed.billing.MedicalBill;
import com.globemed.patient.PatientRecord;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;

/**
 * Payment Methods Analysis Visitor - Fixed to match actual database schema
 * Analyzes payment method preferences and effectiveness
 */
public class PaymentMethodsAnalysisVisitor implements ReportVisitor {
    private final StringBuilder reportContent = new StringBuilder();
    private final Map<String, PaymentMethodData> paymentMethods = new HashMap<>();
    private final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");

    private double totalPayments = 0;
    private int totalTransactions = 0;
    private int totalBills = 0;

    @Override
    public void visit(PatientRecord patient) {
        if (reportContent.length() == 0) {
            reportContent.append(repeatString("=", 90)).append("\n");
            reportContent.append("    PAYMENT METHODS ANALYSIS REPORT\n");
            reportContent.append(repeatString("=", 90)).append("\n");
            reportContent.append("Generated: 2025-08-30 15:48:58 UTC\n");
            reportContent.append("Generated by: isharax9\n");
            reportContent.append(repeatString("=", 90)).append("\n\n");
        }
    }

    @Override
    public void visit(Appointment appointment) {
        // Not used for this report
    }

    @Override
    public void visit(MedicalBill bill) {
        totalBills++;

        // Analyze patient payments
        if (bill.getAmountPaid() > 0) {
            String patientPaymentMethod = determinePatientPaymentMethod(bill);
            PaymentMethodData patientData = paymentMethods.getOrDefault(patientPaymentMethod,
                    new PaymentMethodData(patientPaymentMethod));
            patientData.addPayment(bill.getAmountPaid(), bill);
            paymentMethods.put(patientPaymentMethod, patientData);

            totalPayments += bill.getAmountPaid();
            totalTransactions++;
        }

        // Analyze insurance payments
        if (bill.getInsurancePaidAmount() > 0) {
            String insuranceMethod = "Insurance";
            PaymentMethodData insuranceData = paymentMethods.getOrDefault(insuranceMethod,
                    new PaymentMethodData(insuranceMethod));
            insuranceData.addPayment(bill.getInsurancePaidAmount(), bill);
            paymentMethods.put(insuranceMethod, insuranceData);

            totalPayments += bill.getInsurancePaidAmount();
            totalTransactions++;
        }
    }

    private String determinePatientPaymentMethod(MedicalBill bill) {
        // Enhanced logic to determine payment method based on bill characteristics
        // This is a simplified approach - you might want to add actual payment method fields

        String patientId = bill.getPatientId();
        double amount = bill.getAmountPaid();

        // Simple heuristic-based method determination
        if (patientId.toLowerCase().contains("corp") || patientId.toLowerCase().contains("company")) {
            return "Corporate Account";
        } else if (amount > 1000) {
            return "Bank Transfer"; // Large amounts typically bank transfers
        } else if (amount < 50) {
            return "Cash"; // Small amounts often cash
        } else if (bill.getServiceDescription().toLowerCase().contains("emergency")) {
            return "Credit Card"; // Emergency services often credit card
        } else {
            // Random distribution for demonstration - replace with actual logic
            String[] methods = {"Credit Card", "Debit Card", "Cash", "Check", "Online Payment"};
            return methods[Math.abs(bill.getBillId() % methods.length)];
        }
    }

    @Override
    public String getReport() {
        generateOverview();
        generateMethodBreakdown();
        generateEfficiencyAnalysis();
        generateTrendAnalysis();
        generateRecommendations();
        return reportContent.toString();
    }

    private void generateOverview() {
        reportContent.append("ðŸ’³ PAYMENT METHODS OVERVIEW\n");
        reportContent.append(repeatString("-", 60)).append("\n");
        reportContent.append(String.format("Total Payment Methods: %d\n", paymentMethods.size()));
        reportContent.append(String.format("Total Payment Transactions: %d\n", totalTransactions));
        reportContent.append(String.format("Total Bills Processed: %d\n", totalBills));
        reportContent.append(String.format("Total Payments Processed: $%,.2f\n", totalPayments));

        double avgTransaction = totalTransactions > 0 ? totalPayments / totalTransactions : 0;
        double paymentRate = totalBills > 0 ? ((double) totalTransactions / totalBills) * 100 : 0;

        reportContent.append(String.format("Average Transaction Amount: $%,.2f\n", avgTransaction));
        reportContent.append(String.format("Payment Transaction Rate: %.1f%%\n", paymentRate));
        reportContent.append("\n");
    }

    private void generateMethodBreakdown() {
        reportContent.append("ðŸ“Š PAYMENT METHOD BREAKDOWN\n");
        reportContent.append(repeatString("-", 100)).append("\n");
        reportContent.append(String.format("%-20s | %-8s | %-15s | %-12s | %-12s | %-12s | %-8s\n",
                "Payment Method", "Count", "Total Amount", "Avg Amount", "Min Amount", "Max Amount", "% Total"));
        reportContent.append(repeatString("-", 100)).append("\n");

        paymentMethods.values().stream()
                .sorted((p1, p2) -> Double.compare(p2.getTotalAmount(), p1.getTotalAmount()))
                .forEach(method -> {
                    double percentage = totalPayments > 0 ? (method.getTotalAmount() / totalPayments) * 100 : 0;
                    reportContent.append(String.format("%-20s | %-8d | $%-14.2f | $%-11.2f | $%-11.2f | $%-11.2f | %6.1f%%\n",
                            method.getMethodName(),
                            method.getTransactionCount(),
                            method.getTotalAmount(),
                            method.getAverageAmount(),
                            method.getMinAmount(),
                            method.getMaxAmount(),
                            percentage));
                });

        reportContent.append(repeatString("-", 100)).append("\n");
        reportContent.append(String.format("%-20s | %-8d | $%-14.2f | $%-11.2f | %-12s | %-12s | %6.1f%%\n",
                "TOTAL", totalTransactions, totalPayments,
                totalTransactions > 0 ? totalPayments / totalTransactions : 0, "-", "-", 100.0));
        reportContent.append("\n");
    }

    private void generateEfficiencyAnalysis() {
        reportContent.append("âš¡ PAYMENT METHOD EFFICIENCY\n");
        reportContent.append(repeatString("-", 80)).append("\n");
        reportContent.append(String.format("%-20s | %-12s | %-15s | %-15s | %-12s\n",
                "Payment Method", "Success Rate", "Avg Process Time", "Transaction Size", "Efficiency"));
        reportContent.append(repeatString("-", 80)).append("\n");

        paymentMethods.values().stream()
                .sorted((p1, p2) -> Double.compare(p2.getEfficiencyScore(), p1.getEfficiencyScore()))
                .forEach(method -> {
                    double successRate = method.getSuccessRate();
                    String processTime = method.getEstimatedProcessTime();
                    String transactionSize = method.getTransactionSizeCategory();
                    double efficiency = method.getEfficiencyScore();

                    reportContent.append(String.format("%-20s | %10.1f%% | %-15s | %-15s | %10.1f\n",
                            method.getMethodName(), successRate, processTime, transactionSize, efficiency));
                });
        reportContent.append("\n");
    }

    private void generateTrendAnalysis() {
        reportContent.append("ðŸ“ˆ PAYMENT METHOD PREFERENCES\n");
        reportContent.append(repeatString("-", 60)).append("\n");

        PaymentMethodData mostPopular = paymentMethods.values().stream()
                .max(Comparator.comparing(PaymentMethodData::getTransactionCount))
                .orElse(null);

        PaymentMethodData highestValue = paymentMethods.values().stream()
                .max(Comparator.comparing(PaymentMethodData::getTotalAmount))
                .orElse(null);

        PaymentMethodData highestAverage = paymentMethods.values().stream()
                .max(Comparator.comparing(PaymentMethodData::getAverageAmount))
                .orElse(null);

        PaymentMethodData mostEfficient = paymentMethods.values().stream()
                .max(Comparator.comparing(PaymentMethodData::getEfficiencyScore))
                .orElse(null);

        if (mostPopular != null) {
            reportContent.append(String.format("ðŸ¥‡ Most Popular: %s (%d transactions)\n",
                    mostPopular.getMethodName(), mostPopular.getTransactionCount()));
        }
        if (highestValue != null) {
            reportContent.append(String.format("ðŸ’° Highest Volume: %s ($%,.2f)\n",
                    highestValue.getMethodName(), highestValue.getTotalAmount()));
        }
        if (highestAverage != null) {
            reportContent.append(String.format("ðŸ“Š Highest Average: %s ($%.2f/transaction)\n",
                    highestAverage.getMethodName(), highestAverage.getAverageAmount()));
        }
        if (mostEfficient != null) {
            reportContent.append(String.format("âš¡ Most Efficient: %s (%.1f efficiency score)\n",
                    mostEfficient.getMethodName(), mostEfficient.getEfficiencyScore()));
        }

        // Payment method distribution analysis
        reportContent.append("\nðŸ’³ PAYMENT DIVERSITY:\n");
        if (paymentMethods.size() >= 5) {
            reportContent.append("ðŸŸ¢ Good payment method diversity\n");
        } else if (paymentMethods.size() >= 3) {
            reportContent.append("ðŸŸ¡ Moderate payment method options\n");
        } else {
            reportContent.append("ðŸ”´ Limited payment method options\n");
        }
        reportContent.append("\n");
    }

    private void generateRecommendations() {
        reportContent.append("ðŸ’¡ PAYMENT OPTIMIZATION RECOMMENDATIONS\n");
        reportContent.append(repeatString("-", 60)).append("\n");

        // Find underutilized payment methods
        PaymentMethodData leastUsed = paymentMethods.values().stream()
                .min(Comparator.comparing(PaymentMethodData::getTransactionCount))
                .orElse(null);

        // Find most efficient method
        PaymentMethodData mostEfficient = paymentMethods.values().stream()
                .max(Comparator.comparing(PaymentMethodData::getEfficiencyScore))
                .orElse(null);

        reportContent.append("ðŸŽ¯ STRATEGIC RECOMMENDATIONS:\n");

        if (leastUsed != null && leastUsed.getTransactionCount() > 0) {
            double utilizationRate = totalTransactions > 0 ?
                    ((double) leastUsed.getTransactionCount() / totalTransactions) * 100 : 0;
            if (utilizationRate < 5) {
                reportContent.append(String.format("  â€¢ Consider promoting %s (currently %.1f%% usage)\n",
                        leastUsed.getMethodName(), utilizationRate));
            }
        }

        if (mostEfficient != null) {
            reportContent.append(String.format("  â€¢ Promote %s for better efficiency\n",
                    mostEfficient.getMethodName()));
        }

        // Check for missing popular methods
        boolean hasOnlinePayment = paymentMethods.containsKey("Online Payment");
        boolean hasCreditCard = paymentMethods.containsKey("Credit Card");
        boolean hasDigitalWallet = paymentMethods.containsKey("Digital Wallet");

        reportContent.append("\nðŸ’³ PAYMENT METHOD ENHANCEMENTS:\n");
        if (!hasOnlinePayment) {
            reportContent.append("  â€¢ Implement online payment portal\n");
        }
        if (!hasDigitalWallet) {
            reportContent.append("  â€¢ Consider digital wallet integration (Apple Pay, Google Pay)\n");
        }
        reportContent.append("  â€¢ Offer payment method incentives for preferred methods\n");
        reportContent.append("  â€¢ Monitor transaction fees by payment method\n");
        reportContent.append("  â€¢ Implement contactless payment options\n");

        // Efficiency improvements
        reportContent.append("\nâš¡ EFFICIENCY IMPROVEMENTS:\n");
        reportContent.append("  â€¢ Automate payment processing where possible\n");
        reportContent.append("  â€¢ Reduce manual payment entry\n");
        reportContent.append("  â€¢ Implement real-time payment verification\n");
        reportContent.append("  â€¢ Provide payment method education to patients\n");

        // Security and compliance
        reportContent.append("\nðŸ”’ SECURITY & COMPLIANCE:\n");
        reportContent.append("  â€¢ Ensure PCI compliance for card payments\n");
        reportContent.append("  â€¢ Implement fraud detection systems\n");
        reportContent.append("  â€¢ Regular security audits of payment systems\n");
        reportContent.append("  â€¢ Patient data protection measures\n");

        reportContent.append("\n");
        reportContent.append(repeatString("=", 90)).append("\n");
        reportContent.append("End of Payment Methods Analysis Report\n");
        reportContent.append(repeatString("=", 90)).append("\n");
    }

    private String repeatString(String str, int count) {
        return str.repeat(count);
    }

    // PaymentMethodData helper class
    private static class PaymentMethodData {
        private final String methodName;
        private double totalAmount = 0;
        private int transactionCount = 0;
        private double minAmount = Double.MAX_VALUE;
        private double maxAmount = 0;
        private final List<Double> amounts = new ArrayList<>();

        public PaymentMethodData(String methodName) {
            this.methodName = methodName;
        }

        public void addPayment(double amount, MedicalBill bill) {
            totalAmount += amount;
            transactionCount++;
            amounts.add(amount);

            if (amount < minAmount) minAmount = amount;
            if (amount > maxAmount) maxAmount = amount;
        }

        public String getMethodName() { return methodName; }
        public double getTotalAmount() { return totalAmount; }
        public int getTransactionCount() { return transactionCount; }
        public double getAverageAmount() {
            return transactionCount > 0 ? totalAmount / transactionCount : 0;
        }
        public double getMinAmount() {
            return minAmount == Double.MAX_VALUE ? 0 : minAmount;
        }
        public double getMaxAmount() { return maxAmount; }

        public double getSuccessRate() {
            // Simplified success rate - in reality, this would track failed transactions
            return 100.0; // Assuming all recorded transactions were successful
        }

        public String getEstimatedProcessTime() {
            // Estimated processing time based on payment method
            switch (methodName.toLowerCase()) {
                case "cash": return "Immediate";
                case "credit card": return "1-2 minutes";
                case "debit card": return "1-2 minutes";
                case "bank transfer": return "1-3 days";
                case "check": return "3-5 days";
                case "online payment": return "Few seconds";
                case "insurance": return "30-60 days";
                default: return "Varies";
            }
        }

        public String getTransactionSizeCategory() {
            double avg = getAverageAmount();
            if (avg > 1000) return "Large";
            else if (avg > 100) return "Medium";
            else return "Small";
        }

        public double getEfficiencyScore() {
            // Composite efficiency score based on speed, reliability, and cost
            double speedScore = getSpeedScore();
            double reliabilityScore = getSuccessRate();
            double volumeScore = Math.min(100, (transactionCount / 10.0) * 100); // Max score at 10+ transactions

            return (speedScore * 0.4 + reliabilityScore * 0.4 + volumeScore * 0.2);
        }

        private double getSpeedScore() {
            switch (methodName.toLowerCase()) {
                case "cash": return 100;
                case "online payment": return 95;
                case "credit card": return 90;
                case "debit card": return 90;
                case "check": return 60;
                case "bank transfer": return 70;
                case "insurance": return 40;
                default: return 70;
            }
        }
    }
}